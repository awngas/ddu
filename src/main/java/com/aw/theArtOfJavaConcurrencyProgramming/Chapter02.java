package com.aw.theArtOfJavaConcurrencyProgramming;

public class Chapter02 {
    public static void main(String[] args) {
        System.out.println("java并非机制的底层实现原理");
    }
    /**
     2.1 volatile的应用
     1.volatile的定义与实现原理
     Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，
     为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。
     Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，
     Java线程内存模型确保所有线程看到这个变量的值是一致的。

     CPU的术语定义
     内存屏障[memory barriers]:是一组处理器指令,用于实现对内存操作的顺序限制
     缓存行[cache line]:缓存中可以分配的最小存储单位,处理器填写缓存线时会加载整个缓存线,需要使用多个主内存读周期
     原子操作[atomic operations]:不可中断的一个或一系列操作
     缓存行填充[cache line fill]:当处理器识别到内存中读取操作数是可缓存的,
                                  处理器读取整个缓存行到适当的缓存(L1,L2,L3的或所有)
     缓存命中[cache hit]:如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时,
                         处理器从缓存中读取操作数,而不是从内存读取
     写命中[write hit]:当处理器将操作数写回到一个内存缓存的区域时,它首先检查这个缓存的内存地址是否在缓存行中,
                       如果存在一个有效的缓存行,则处理器将这个操作数写回到缓存,而不是写回到内存,
                       这个操作被称为写命中
     写缺失[write misses the cache]:一个有效的缓存行被写入到不存在的内存区域

     volatile如何来保证可见性
     java代码 instance = new Singleton() //instance是volatile变量
     转成汇编代码如下:
     0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
     有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码(lock)
     Lock前缀的指令在多核处理器下会引发两件事:
     1）将当前处理器缓存行的数据写回到系统内存。
     2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
     ####这段讲的很垃圾具体看http://www.importnew.com/18126.html(Java并发编程：volatile关键字解析)#####
     为了提高处理速度，处理器不直接和内存进行通信，
     而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再对缓存中数据进行操作，
     但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，
     JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。
     但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。
     所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，
     每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
     当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，
     当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
     下面来具体讲解volatile的两条实现原则。
     ###############这段讲的很烂#############################################
     1）Lock前缀指令会引起处理器缓存回写到内存。
     Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，
     处理器可以独占任何共享内存。因为它会锁住总线，导致其他CPU不能访问总线，
     不能访问总线就意味着不能访问系统内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，
     毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，
     对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，
     如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，
     并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，
     缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。

     2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。
     IA-32处理器和Intel 64处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。
     在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。
     处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。
     例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，
     而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，
     强制执行缓存行填充。

     2.2 synchronized的实现原理与应用
     synchronized基础:java中的每一个对象都可以做为锁.
     对于普通同步方法,锁是当前实例对象.
     对于静态同步方法,锁是当前类的Class对象.
     对于同步方法块,锁是synchronized括号里配置的对象
     当一个线程视图访问同步代码块时,它首先必须得到锁，退出或抛出异常时必须释放锁。

     那么锁到底存在哪里呢？锁里面会存储什么信息呢？
     从JVM规范中可以看到Synchonized在JVM里的实现原理，
     JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。
     代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，
     细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

     monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结
     束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有
     一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter
     指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

     ########monitor没有讲

     2.2.1 java对象头
     synchronized用的锁是存在Java对象头里的.
     对象头中包含:
     长度       内容                     说明
     32/64bit   Mark Word                存储对象的hashCode或锁信息等
     32/64bit   Class Metadata Address   存储到对象类型数据的指针
     32/64bit   Array length             数组的长度(如果当前对象时数组)

     Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构:
     锁状态     25bit            4bit           1bit是否偏向锁   2bit锁标志位
     无锁状态   对象的hashcode   对象分代年龄   0                01

     在运行期间,Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数:
     锁状态: 轻量级锁,重量级锁,GC标记,偏向锁
     64位虚拟机下,Mark Word是64bit大小的,与32位Mark Word结构不同.

     2.2.2 锁的升级与对比
     Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：
     无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，
     这几个状态会随着竞争情况逐渐升级,锁可以升级但不能降级.

     1.偏向锁
     大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
     当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
     以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，
     只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。
     如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，
     则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

     ####CAS，Compare and Swap即比较并替换，设计并发算法时常用到的一种技术
     ####CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，
     ####将内存值修改为B并返回true，否则什么都不做并返回false。

     （1）偏向锁的撤销   ####看不懂
     偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，
     持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。
     它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
     如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，
     遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，
     要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
     图2-1中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。

     2.轻量级锁
     （1）轻量级锁加锁
     线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，
     并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
     然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，
     表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
     （2）轻量级锁解锁
     轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。
     如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。图2-2是两个线程同时争夺锁，导致锁膨胀的流程图。

     因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，
     就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，
     当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

     3.锁的优缺点对比
     偏向锁:
       优点:加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距
       缺点:如果线程间存在锁竞争,会带来额外的锁撤销的消耗
       适用场景:适用于只有一个线程访问同步块场景
     轻量级锁:
       优点:竞争的线程不会阻塞,提高了程序的响应速度
       缺点:如果始终得不到锁竞争的线程,使用自旋会消耗CPU
       适用场景:追求响应时间,同步块执行速度非常块
     重量级锁:
       优点:线程竞争不使用自旋,不会消耗CPU
       缺点:线程阻塞,响应时间缓慢
       适用场景:追求吞吐量,同步块执行速度较长

     2.3　原子操作的实现原理
     原子操作（atomic operation）意为“不可被中断的一个或一系列操作”
     1.术语定义
     缓存行[Cache line]:缓存的最小操作单位
     比较并交换[Compare and Swap]:CAS操作需要输入两个数值,一个旧值(期望操作前的值)和一个新值,在操作期间先比较
                                  旧值有没有发生变化,如果没有发送变化,才交换成新值,发生了变化则不交换
     CPU流水线[CPU pipeline]:CPU流水线的工作方式就像工业生产上的装配流水线,在CPU中5~6个不同功能的电路单元组成
           组成一条指令处理流水线,然后将一条X86指令分成5~6步后再由这些电路单元分别执行,
           这样就能实现在一个CPU时钟周期完成一条指令,因此提高CPU的运算速度.
     内存顺序冲突[Memory order violation]:内存顺序冲突一般是由假共享引起的,假共享是指多个CPU同时修改同一个
           缓存行的不同部分而引起其中一个CPU的操作无效,当出现这个内存顺序冲突时,CPU必须清空流水线
     2.处理器如何实现原子操作
     处理器保证从系统内存中读取或者写入一个字节是原子的
     处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。
     （1）使用总线锁保证原子性
     所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，
     那么该处理器可以独占共享内存。 ####讲的太烂了

     （2）使用缓存锁保证原子性
     但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，
     其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大.处理器某些场合使用缓存锁代替总线锁定
     频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，
     并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，
     而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，
     因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，
     当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如图2-3所示的例子中，
     当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。

     但是有两种情况下处理器不会使用缓存锁定。
     第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，
     则处理器会调用总线锁定。
     第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，
     就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

     针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测
     试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指
     令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

     3.Java如何实现原子操作
     在Java中可以通过锁和循环CAS的方式来实现原子操作。
     （1）使用循环CAS实现原子操作
     JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的
     （2）CAS实现原子操作的三大问题
     1）ABA问题
     一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。
     解决使用版本号
     java类:AtomicStampedReference
     2）循环时间长开销大
     自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如
     果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第
     一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间
     取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候
     因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而
     提高CPU的执行效率。
     ######说了这么多也没说到底支持不支持
     3）只能保证一个共享变量的原子操作
     对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，
     就是把多个共享变量合并成一个共享变量来操作。
     AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作
     （3）使用锁机制实现原子操作
     锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，
     有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，
     即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。


     */
}
